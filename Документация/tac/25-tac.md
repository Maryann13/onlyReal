# Оптимизация Доступные выражения !heading

### Команда Roslyn

#### Постановка задачи

Задача состояла в реализации оптимизации на основе анализа доступных выражений, использующего итерационный алгоритм.

#### Зависимости задач в графе задач
Данная задача зависит от итерационного алгоритма для доступных выражений / обобщённого итерационного алгоритма.

От задачи зависит:
* Задача не порождает новых зависимостей

#### Теория

*Постановка задачи.* Если в программе имеются общие подвыражения, вынести их во временную переменную.
Пример:
```
{
	int t1, t2, t3, i, a;
	t1 = 4 * i;
	if (true)
	{
		i = a;
		t3 = 4 * i;
	}
	t2 = 4 * i;
}
```
После применения оптимизации программа должна стать эквивалентной следующей:
```
{
	int t1, t2, t3, i, a;
	#t0 = 4 * i;
	t1 = #t0;
	if (true)
	{
		i = a;
		#t0 = 4 * i;
		t3 = #t0;
	}
	t2 = #t0;
}
```
*Определение.* Выражение `x + y` доступно в точке p если любой путь от входа к p вычисляет `x+y` и после последнего вычисления до достижения p нет присваиваний `x` и `y`. 

#### Особенности реализации

Для использования данной оптимизации необходимо выполнить следующий код:
```csharp
// Построение базовых блоков по трёхадресному коду исходной программы
var blocks = new Block(treeCode).GenerateBlocks();
// Применение оптимизации (итеративный алгоритм запускается внутри метода ApplyOptimization)
var availableExprsOptimizer = new AvailableExprsOptimizer();
CFG cfg = availableExprsOptimizer.ApplyOptimization(blocks);
```
Функция _ApplyOptimization_ строит по базовым блокам исходной программы граф потока управления и запускает для него обобщённый итерационный алгоритм, используя передаточную функцию для доступных выражений. На выходе этой функции — новый граф потока управления.

#### Тесты

Пример исходной программы:
```
{
	int t1, t2, t3, i, a, x;
	int u1, u2, u3, u4, u5;
	i = 2;
	t1 = 4 * i;
	x = 4 * i;
	u1 = 5 * i;
	if (true)
	{
		u3 = 5 * i;
	}
	t2 = 4 * i;
	u2 = 5 * i;
	u4 = 6 * i;
	u5 = 5 * i;
}
```
После применения оптимизации программа становится эквивалентной следующей:
```
{
	int t1, t2, t3, i, a, x;
	int u1, u2, u3, u4, u5;
	i = 2;
	#t1 = 4 * i;
	#t0 = 5 * i;
	t1 = #t1;
	x = #t1;
	u1 = #t0;
	if (true)
	{
		u3 = #t0;
	}
	t2 = #t1;
	u2 = #t0;
	u4 = 6 * i;
	u5 = #t0;
}
```
Результат в трёхадресном коде:
```
entry:

           i = 2
           #t1 = 4 * i
           #t0 = 5 * i
           t1 = #t1
           x = #t1
           u1 = #t0
           if True goto label_0

           goto label_1

label_0:
           u3 = #t0

           t2 = #t1
           u2 = #t0
           u4 = 6 * i
           u5 = #t0
```

[Вверх](#содержание)